## Упражнение 1.5

Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он работает, аппликативным или нормальным. Бен определяет такие две процедуры:

```racket
(define (p) (p))


(define (test x y)
    (if (= x 0)
        0
        y))
```

Затем он вычисляет выражение:

```racket
(test 0 (p))

```

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений?
Какое Поведение он увидит, если интерпретатор использует нормальный порядок?
Объясните Ваш ответ. (Предполагается, что правило вычисления особой формы `if` одинаковонезависимо от того, какой порядок вычислений используется. Сначала вычисляется выражение-предикат, и результат определяет, нужно ли вычислять выражение-следствие или альтернативу.)
    
## Решение:

### Аппликативный порядок вычисления.

При этой модели вычисления аргументы не вычисляются, пока не понадобиться их значение.
Иными словами, при вызове `(test 0 (p))`, происходит следующее:
1. Вычисляется выражение-предикат особой формы `if` - `(= x 0)`;
2. Результатом даного вычисления является `true`, поэтому вычисление переходит к следствию и возвращает 0;

Таким образом выражение альтернатива - `(p)`, не вычисляется.

### Нормальный порядок вычисления.

В данном случае, при вызове `(test 0 (p))` сначала происходит вычисление аргументов `0` и `(p)`.
Вычисление `(p)` приведет к ошибке, так как интерпретатор провалиться в бесконечную рекурсию вызовов `(p)`.

[К списку упражнений](../index.md)
