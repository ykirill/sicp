## Упражнение 1.6

Лиза П. Хакер не понимает, почему `if` должна быть особой формой.
"Почему нельзя просто определить её как обычную процедуру с помощью `cond`?" - спрашивает она.
Лизина подруга Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию `if`:

```racket
(define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
        (else else-clause)))
```

Ева показывает Лизе новую программу:
```racket
(new-if (= 2 3) 0 5)
;5

(new-if (= 1 1) 0 5)
;0
```

Обрадованная Лиза переписывает через `new-if` программу вычисления квадратного корня:

```racket
(define (sqrt-iter guess x)
    (new-if (good-enough? guess x)
        gues
        (sqrt-iter (improve guess x)
            x)))
```

Что получится, когда Лиза попытается использовать эту процедуру для вычисления квадратных корней? Объясните.
    
## Решение:

При использовании в качестве механизма ветвления процедуры `new-if` в данном случае происходит следующая последовательность вызовов:

1. Вызов `sqrt`: `(sqrt 4)`;
2. Присвоение параметру `x` процедуры `sqrt` переданного значения - 4;
3. Вызов `sqrt-iter`: `(sqrt-iter 1.0 4)`;
4. Присвоение параметру `guess` процедуры `sqrt-iter` переданного значения - 1.0, значение 4 было полученно изокружения процедуры;
5. Вызов `new-if`, предикатом, которого выступает процедура `good-enouth?`, а ветвями `guess` = 1.0 и процедура `sqrt-iter`;
    1. Вычисляется предикат `(good-enough? guess x)` для guess = 1.0 и x = 4 - `(< (abs (- (square guess) x)) 0.001)` => `false`;
    3. Вычисление переходит в ветку `else-clause` процедуры `new-if`;
6. Вызов `sqrt-iter`: `(sqrt-iter (improve 1.0 4) 4)`;
    1. Вызов `improve`: `(improve 1.0 4)`;
        1. Вызов `average`: `(average 1.0 (/ 4 1.0))`;
            1. Вычисление `(/ 4 1.0)` => 4.0;
            2. Вычисление `(/ (+ 1.0 4.0) 2)` => 2.5;
7. Вызов `new-if`, предикатом, которого выступает процедура `good-enouth?`, а ветвями `guess` = 2.5 и процедура `sqrt-iter`;
    1. Вычисляется предикат `(good-enough? guess x)` для guess = 2.5 и x = 4 - `(< (abs (- (square guess) x)) 0.001)` => `false`;
    2. Вычисление переходит в ветку `else-clause` процедуры `new-if`;
8. Вызов `sqrt-iter`: `(sqrt-iter (improve 2.5 4) 4)`;
    1. Вызов `improve`: `(improve 2.5 4)`;
        1. Вызов `average`: `(average 2.5 (/ 4 2.5))`;
            1. Вычисление `(/ 4 2.5)` => 1.6;
            2. Вычисление `(/ (+ 1.6 2.5) 2)` => 2.05;
9. Вызов `new-if`, предикатом, которого выступает процедура `good-enouth?`, а ветвями `guess` = 2.05 и процедура `sqrt-iter`;
    1. Вычисляется предикат `(good-enough? guess x)` для guess = 2.05 и x = 4 - `(< (abs (- (square guess) x)) 0.001)` => `false`;
    2. Вычисление переходит в ветку `else-clause` процедуры `new-if`;
10. Вызов `sqrt-iter`: `(sqrt-iter (improve 2.05 4) 4)`;
    1. Вызов `improve`: `(improve 2.05 4)`;
        1. Вызов `average`: `(average 2.05 (/ 4 2.05))`;
            1. Вычисление `(/ 4 2.05)` => 1.9512195121951221;
            2. Вычисление `(/ (+ 2.05 1.9512195121951221) 2)` => 2.000609756097561;
11. Вызов `new-if`, предикатом, которого выступает процедура `good-enouth?`, а ветвями `guess` = 2.000609756097561 и процедура `sqrt-iter`;
    1. Вычисляется предикат `(good-enough? guess x)` для guess = 2.000609756097561 и x = 4 - `(< (abs (- (square guess) x)) 0.001)` => `false`;
    2. Вычисление переходит в ветку `else-clause` процедуры `new-if`;

10. Вызов `sqrt-iter`: `(sqrt-iter (improve 2.000609756097561 4) 4)`;
    1. Вызов `improve`: `(improve 2.000609756097561 4)`;
        1. Вызов `average`: `(average 2.000609756097561 (/ 4 2.000609756097561))`;
            1. Вычисление `(/ 4 2.000609756097561)` => 1.9993904297470284;
            2. Вычисление `(/ (+ 2.05 1.9512195121951221) 2)` => 2.0000000929222947;
11. Вызов `new-if`, предикатом, которого выступает процедура `good-enouth?`, а ветвями `guess` = 2.0000000929222947 и процедура `sqrt-iter`;
    1. Вычисляется предикат `(good-enough? guess x)` для guess = 2.0000000929222947 и x = 4 - `(< (abs (- (square guess) x)) 0.001)` => `true`;
    2. Вычисление переходит в ветку `else-clause` процедуры `new-if`;

Стоп! Но ведь при `<predicate> == true` должна вычисляться ветка `then-clause`. В чем дело?
Нет, ведь при выполнении `new-if` происходит не совсем это.
Давайте разберёмся в вызове этой процедуры.
Для начала вспомним, какой порядк вычисления по умолчанию использует интерпретатор языка.
Это аппликативный порядок, который характеризуется вычислением аргументов, а уже потом самой процедуры.
Т.е. `(new-if <predicate> <t-c> <e-c>)` всегда вычисляется в следующем порядке:

1. Вычисление предиката;
2. Вычисление выражения для ветки следствия;
3. Вычисление выражения для ветки альтернативы;
4. Вычисление тела процедуры.

В нашем случае, на третий шаг вычисления порождает бесконечную рекурсию. И интерпретатор не может вычислить квадратный корень числа.

[К списку упражнений](../index.md)
